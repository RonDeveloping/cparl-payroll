generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native"]
}

datasource db {
  provider = "postgresql"
}

// ==========================================
// ===== USER SERVICE (Authentication)  =====
// ==========================================

model User {
  id           String   @id @default(cuid()) // Internal, never changes
  slug         String   @unique // Normalized email, all lowercase
  email  String   @unique @map("email") //original format user inputs; case-insensitive in practice.
  emailVerifiedAt       DateTime? @map("email_verified_at")
  pendingEmail  String?   @map("pending_email")
  
  phone  String?   @unique @map("phone")
  phoneVerifiedAt       DateTime? @map("phone_verified_at")
  pendingPhone  String?   @map("pending_phone")
  
  passwordHash String?  @map("password_hash")
  contactId    String   @unique @map("contact_id") // soft link only (No @relation)
  
  createdAt    DateTime @default(now()) @map("created_at") 
  updatedAt    DateTime @updatedAt @map("updated_at")
  last2FAAt          DateTime? @map("last_2fa_at")

  twoFactorCode     TwoFactorCode?
  emailVerifications  EmailVerification[]
  phoneVerification  PhoneVerification?
  paymentCards      PaymentCard[]

  @@map("user")
}

model EmailVerification {
  id        String   @id @default(cuid())
  token     String   @unique
  user      User @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String @map("user_id")
  type      TokenType @default(EMAIL_VERIFICATION)
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("email_verification")
  @@index([userId, type]) // Helps performance when looking up codes for a specific user
}

model PhoneVerification {
  id        String   @id @default(cuid())
  code      String    // The 6-digit code
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String  @unique @map("user_id")
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")
  @@map("phone_verification")
  @@index([userId]) // Helps performance when looking up codes for a specific user
}

// Used every time they log in (2FA)
model TwoFactorCode {
  id        String   @id @default(cuid())
  code      String   // 6-digit numeric
  userId    String   @unique @map("user_id")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")

  @@map("two_factor_codes")
  @@index([userId]) // Faster lookup during login
}

model PaymentCard {
  id                String   @id @default(cuid())
  userId            String   @map("user_id")
  brand             String
  last4             String   @map("last4")
  expMonth          Int      @map("exp_month")
  expYear           Int      @map("exp_year")
  cardholderName    String?  @map("cardholder_name")
  billingPostalCode String?  @map("billing_postal_code")
  paymentMethodId   String   @map("payment_method_id")
  isDefault         Boolean  @default(false) @map("is_default")
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("payment_card")
}

// ==========================================
// ===== CONTACT SERVICE (Identity)     =====
// ==========================================

model Contact {
  id          String   @id @default(cuid())
  coreName   String   @map("core_name") //John/ACE Enterprise
  kindName  String   @map("kind_name") //Doe/Inc.
  middleName  String?  @map("middle_name")
  prefix      String?
  suffix      String?
  aliasName   String?  @map("alias_name") //Johnie a nick name /Starbucks a DBA(doing bz as)
  displayName String?  @map("display_name") //Johnnie Doe
  source      NameSource? @map("source") //USER, SUPPORT, IMPORT, SYSTEM
  subject     Subject 
  
  isActive    Boolean  @default(true) @map("is_active")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  legalNameHistory          LegalNameHistory[]
  conversationalNameHistory ConversationalNameHistory[]
  addresses                 Address[]
  emails                    Email[]
  phones                    Phone[]

  @@map("contact")
}

model LegalNameHistory {
  id            String    @id @default(cuid())
  contactId     String    @map("contact_id")
  coreName      String    @map("core_name")
  kindName      String    @map("kind_name")
  middleName    String?   @map("middle_name")
  effectiveFrom DateTime  @map("effective_from")
  effectiveTo   DateTime? @map("effective_to")
  changedBy     String?   @map("changed_by") //e.g. adminId / system
  reason        String?
  source        NameSource?
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")
  contact Contact @relation(fields: [contactId], references: [id]) //so prisma generates the foreign key constraint for us:  ALTER TABLE "LegalNameHistory" ADD CONSTRAINT "LegalNameHistory_contactId_fkey" FOREIGN KEY ("contactId") REFERENCES "Contact"("id") to ensure referential integrity.

  @@index([contactId, effectiveFrom]) //composite index for efficient querying of time in history table
  @@map("legal_name_history")
}

model ConversationalNameHistory {
  id            String                    @id @default(cuid())
  contactId     String                    @map("contact_id")
  suffix        String?
  prefix        String?
  aliasName     String?                   @map("alias_name")
  displayName   String?                   @map("display_name")
  source        NameSource?
  effectiveFrom DateTime                  @map("effective_from")
  effectiveTo   DateTime?                 @map("effective_to")
  createdAt     DateTime                  @default(now()) @map("created_at")
  updatedAt     DateTime                  @updatedAt @map("updated_at")
  contact Contact @relation(fields: [contactId], references: [id])

  @@index([contactId, effectiveFrom])
  @@map("conversational_name_history")
}

model Address {
  id          String  @id @default(cuid())
  contactId   String  @map("contact_id")
  street      String
  city        String
  province    String
  postalCode  String  @map("postal_code")
  country     String
  addressHash String  @map("address_hash") //sha256(`${street}|${city}|${province}|${postalCode}|${country}`)
  isPrimary   Boolean @default(false) @map("is_primary")

  contact Contact @relation(fields: [contactId], references: [id])

  @@unique([contactId, addressHash])//composite unique constraint to prevent duplicate addresses for same contact
  @@index([contactId])//speed up queries per contactID
  @@map("address")
}

/*
Remeber in migration SQL file, add:
CREATE UNIQUE INDEX one_primary_email_per_contact
ON "Email"(contactId)
WHERE isPrimary = true;

CREATE UNIQUE INDEX one_primary_address_per_contact
ON "Address"(contactId)
WHERE isPrimary = true;

CREATE UNIQUE INDEX one_primary_phone_per_contact
ON "Phone"(contactId)
WHERE isPrimary = true;
*/

model Email {
  id           String   @id @default(cuid())
  contactId    String   @map("contact_id")
  isPrimary    Boolean  @default(false) @map("is_primary")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")
  emailAddress String   @map("email_address") //it's case-insensitive in practice, but Prisma does not support unique constraints on case-insensitive yet, so we enforce lowercase in application logic

  contact Contact @relation(fields: [contactId], references: [id])

  @@unique([contactId, emailAddress])
  @@index([contactId])
  @@map("email")
}

model Phone {
  id        String      @id @default(cuid())
  contactId String      @map("contact_id") //it is explicitly given; direct access to ID w/o fetching the relation; otherwise Prisma will create a hidden field.
  number    String
  type      PhoneType? @default(MOBILE) @map("type")
  isPrimary Boolean     @default(false) @map("is_primary")

  contact Contact @relation(fields: [contactId], references: [id])

  @@unique([contactId, number])
  @@index([contactId])
  @@map("phone")
}

// ==========================================
// ===== TENANT SERVICE (Settings)      =====
// ==========================================

model Tenant {
  id             String   @id @default(cuid())
  contactId      String   @map("contact_id") //soft link only (No @relation)
  nameCached    Json   @map("name_cached")
  slug           String   @unique
  businessNumber String?  @map("business_number")
  isActive       Boolean  @default(true) @map("is_active")
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  members       TenantUser[]
  settings      TenantSettings?
  payrollCycles PayrollCycle[]
  departments   Department[]

  @@map("tenant")
}
//TODO: use a middleware or a library (like Prisma's $extends) to automatically inject where: { tenantId: activeTenantId } into every query. This ensures you never forget to filter by the tenant.

model TenantUser {
  id        String   @id @default(cuid())
  userId    String   @map("user_id")
  role      UserRole  @default(EMPLOYEE) @map("role")
  createdAt DateTime @default(now()) @map("created_at")

  tenant Tenant @relation(fields: [tenantId], references: [id])
  tenantId  String   @map("tenant_id")

  @@unique([tenantId, userId])
  @@index([userId])
  @@map("tenant_user")
}

model TenantSettings {
  id       String @id @default(cuid())
  tenantId String @unique @map("tenant_id")
  timezone String @default("America/Toronto")

  tenant Tenant @relation(fields: [tenantId], references: [id])
  
  @@map("tenant_settings")
}

model PayrollCycle {
  id        String        @id @default(cuid())
  tenantId  String        @map("tenant_id")
  name      String// e.g., "Weekly Bi-weekly", "Monthly
  frequency PayFrequency @map("frequency")


  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@index([tenantId])
  @@map("payroll_cycle")
}

model Department {
  id       String  @id @default(cuid())
  tenantId String  @map("tenant_id")
  name     String
  code     String?

  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@unique([tenantId, code])
  @@map("department")
}

model ChartOfAccount {
  id        String           @id @default(cuid())
  tenantId  String           @map("tenant_id")
  code      String //acct#
  name      String
  type      AccountType
  category  AccountCategory
  isActive  Boolean          @default(true) @map("is_active")
  createdAt DateTime         @default(now()) @map("created_at")
  updatedAt DateTime         @updatedAt @map("updated_at")

  glMappings GLMapping[] // Mapping logic: Which payroll items point here?

  @@unique([tenantId, code])
  @@index([tenantId])
  @@map("chart_of_account")
}

model GLMapping {
  id                String        @id @default(cuid())
  tenantId          String        @map("tenant_id")
  chartOfAccountId  String        @map("chart_of_account_id")
  mappingType       MappingType  @map("mapping_type")
  earningType       EarningType? @map("earning_type")
  deductionType     DeductionType? @map("deduction_type")
  departmentId      String?       @map("department_id")

  chartOfAccount    ChartOfAccount @relation(fields: [chartOfAccountId], references: [id])

  @@index([tenantId, mappingType])
  @@map("gl_mapping")
}
/*
mapping flow
1	Line Level	Look at earningType (e.g., "Regular") or deductionType (e.g., "Tax").
2	Employee Level	Look at the departmentId and costCenterId associated with that specific JobAssignment.
3	Mapping Level	Find the GLMapping that matches both the type and the department.
4	Journal Level	Add the amount to the running total for that specific GL Account.

journalEntries look like:
5100 - Wages (Eng)	DEBIT	$6,000	Total Regular Pay - Engineering
5100 - Wages (Sales)	DEBIT	$4,000	Total Regular Pay - Sales
2100 - Tax Payable	CREDIT	$2,500	Total Income Tax Withheld
2150 - CPP Payable	CREDIT	$1,000	Total CPP (Employee + Employer)
1010 - Bank Clearing	CREDIT	$6,500	Total Net Pay to be disbursed

Granularity: Analyzes every PayrollLine/Deduction, but exports a Summarized Total per GL Account.
*/




// ==========================================
// ===== PAYROLL SERVICE (Logic)        =====
// ==========================================
//the tenantId acts as a Partition Key and provide row level multi-tenancy isolation by veryfying tenantId in all queries
model Employee {
  id             String          @id @default(cuid())
  tenantId       String          @map("tenant_id")
  contactId      String          @map("contact_id")
  employeeNumber String?         @map("employee_number")
  taxIdEncrypted Bytes           @map("tax_id_encrypted")
  taxIdLast4     String          @map("tax_id_last_4") ////last 4 digits for display/search purposes
  dateOfBirth    DateTime        @map("date_of_birth")
  hireDate       DateTime        @map("hire_date")
  status         EmployeeStatus    @default(ACTIVE) @map("status")
  createdAt      DateTime        @default(now()) @map("created_at")
  updatedAt      DateTime        @updatedAt @map("updated_at")
 // Cached contact info (latest from Contact)
  addressCached Json   @map("address_cached")
  emailCached   String? @map("email_cached")
  phoneCached   Json?  @map("phone_cached")
  //array of ojbect e.g. [{ "number": "+1-613-410-8880", "type": "MOBILE", "isPrimary": true }, {"number": "+1-613-555-1234", "type": "WORK", "isPrimary": false }]
  nameCached    Json   @map("name_cached")

  employments  Employment[]
  payrollRuns  PayrollRunEmployee[]
  bankAccounts BankAccount[]

  @@unique([tenantId, contactId])//for tenant-scoped uniquenessone employee per contact per tenant
  @@unique([tenantId, employeeNumber])//PostgreSQL allows multiple NULLs, even with a unique constraint, so multiple employees per tenant can have employeeNumber = null
  //@unique,@@unique can only be applied to scalar fields (not relations) and full-table level.
  @@map("employee")
}
  /* 
  ALTER TABLE "Employee" 
  ADD CONSTRAINT termination_consistency
  CHECK ( (terminationDate IS NULL AND terminationReason IS NULL)
        OR
        (terminationDate IS NOT NULL AND terminationReason IS NOT NULL)
);
 or/and
  such both or nothing rules can be enforced in app logic: terminationReason != null ⇒ terminationDate != null; Rehire ⇒ clear both
*/

//TODO: will enforce this in service logic: assert(employment.tenantId === employee.tenantId);Ensure service layer validates that employee.tenantId === employment.tenantId.
model Employment {
  id           String    @id @default(cuid())
  tenantId     String    @map("tenant_id")
  employeeId   String    @map("employee_id")
  title        String?
  department   String?
  startDate    DateTime  @map("start_date")
  endDate      DateTime? @map("end_date")
  countryCode  String    @default("CA") @map("country_code")
  provinceCode String    @map("province_code")
  createdAt    DateTime  @default(now()) @map("created_at")

  employee       Employee        @relation(fields: [employeeId], references: [id])
  jobAssignments JobAssignment[] ////e.g. casher $18/hr, stocker $20/hr (Most payroll systems — ADP, Ceridian, Workday payroll mode) — support multiple concurrent job assignments per employment record.

  @@index([tenantId, employeeId, startDate])//tenant-scoped reporting; historical queries and ROE generation
  @@index([employeeId, startDate])//to speed up querying employment history per employee, ordered by startDate; we can't add an index on WHERE endDate IS NULL to speed up querying current employment record per employee via prisma so far
  @@map("employment")
}
/*
TODO: some rule must live at the database level, not the primsa schema level, to enforce data integrity. For example, to ensure that only one active employment record (where endDate IS NULL) exists per employee, we need to create a partial unique index in PostgreSQL by running the following commands in terminal:
npx prisma migrate dev --name add-one-active-employment

Then in the generated migration.sql file, add:
CREATE UNIQUE INDEX "OneActiveEmploymentPerEmployee" ON "Employment" ("employeeId") WHERE "endDate" IS NULL; 

This ensures that only one active employment record (where endDate IS NULL) exists per employee When violated, Prisma will throw: PrismaClientKnownRequestError#P2002

This one active employment rule is for CPP/EI/tax aggregation purposes and for ROE continuity as well as benefit eligibility.
*/

//assume always accessed via Employment, so no tenantId here
//TODO: JobAssignment.startDate >= Employment.startDate; //JobAssignment.endDate <= Employment.endDate (if not null) Note enforcable in Prisma must live in service logic or DB constraints/triggers
model JobAssignment {
  id           String    @id @default(cuid())
  employmentId String    @map("employment_id")
  startDate    DateTime  @map("start_date")
  endDate      DateTime? @map("end_date")
  payRate      Decimal   @db.Decimal(10, 2) @map("pay_rate")
  payType      PayType   @map("pay_type")

  employment   Employment    @relation(fields: [employmentId], references: [id])
  timeEntries  TimeEntry[]
  payrollLines PayrollLine[]

  @@index([employmentId, startDate])
  @@map("job_assignment")
}

//assume always accessed via jobAssignment, so no tenantId here
model TimeEntry {
  id              String   @id @default(cuid())
  jobAssignmentId String   @map("job_assignment_id")
  workDate        DateTime @map("work_date")
  hours           Decimal  @db.Decimal(6, 2)

  jobAssignment JobAssignment @relation(fields: [jobAssignmentId], references: [id])

  @@index([jobAssignmentId, workDate])
  @@map("time_entry")
}

model PayrollRun {
  id          String             @id @default(cuid())
  tenantId    String             @map("tenant_id")//Add only where filtering / reporting / safety benefits outweigh joins otherwise use of FK chain to validate tenant
  periodStart DateTime           @map("period_start")
  periodEnd   DateTime           @map("period_end")
  runDate     DateTime           @map("run_date")
  status      PayrollRunStatus   @default(DRAFT) @map("status")
  createdAt   DateTime           @default(now()) @map("created_at")

  payrollRunEmployees PayrollRunEmployee[]

  @@unique([tenantId, periodStart, periodEnd])//prevent duplicate payroll runs for same period per tenant
  @@map("payroll_run")
}

/*
SUM(hours × payRate) GROUP BY: - employeeId (taxes) - jobAssignmentId (costing)
Taxes, CPP, EI → Employee level
Earnings → JobAssignment level
*/
model PayrollRunEmployee {
  id              String   @id @default(cuid())
  payrollRunId    String   @map("payroll_run_id")
  employeeId      String   @map("employee_id")
  nameSnapshot    String   @map("name_snapshot")// Immutable snapshot fields copied from Employee
  addressSnapshot String   @map("address_snapshot")
  grossPay        Decimal  @db.Decimal(10, 2) @map("gross_pay")
  deductions      Decimal  @db.Decimal(10, 2)
  netPay          Decimal  @db.Decimal(10, 2) @map("net_pay")
  createdAt       DateTime @default(now()) @map("created_at")

  payrollRun    PayrollRun            @relation(fields: [payrollRunId], references: [id])
  employee      Employee              @relation(fields: [employeeId], references: [id])
  payrollLines  PayrollLine[]
  deductionsList Deduction[]
  disbursements PayrollDisbursement[]

  @@unique([payrollRunId, employeeId])//one record per employee per payroll run
  @@map("payroll_run_employee")
}
//Tenant guaranteed by PayrollRun + Employee; One earning type, for one employee, in one payroll run, attributable to one costing source.
model PayrollLine {
  id                   String       @id @default(cuid())
  payrollRunEmployeeId String       @map("payroll_run_employee_id")
  jobAssignmentId      String?      @map("job_assignment_id")
  rate                 Decimal      @db.Decimal(10, 2)//payRate from JobAssignment at time of payroll run creation
  units                Decimal      @db.Decimal(6, 2)//hours from TimeEntry for a payroll period; salary 1 
  amount               Decimal      @db.Decimal(10, 2)
  earningType          EarningType @map("earning_type")

  payrollRunEmployee PayrollRunEmployee @relation(fields: [payrollRunEmployeeId], references: [id])
  jobAssignment      JobAssignment?     @relation(fields: [jobAssignmentId], references: [id])

  @@map("payroll_line")
}

model Deduction {
  id                   String         @id @default(cuid())
  payrollRunEmployeeId String         @map("payroll_run_employee_id")
  type                 DeductionType  @map("type")
  amount               Decimal        @db.Decimal(10, 2)
  createdAt            DateTime       @default(now()) @map("created_at")

  payrollRunEmployee PayrollRunEmployee @relation(fields: [payrollRunEmployeeId], references: [id])

  @@unique([payrollRunEmployeeId, type])//reinforce: one deduction type per payroll run employee
  @@map("deduction")
}

model BankAccount {
  id                String           @id @default(cuid()) @map("id")
  institutionNumber Int              @map("institution_number")
  branchNumber      Int              @map("branch_number")
  accountNumber     String           @map("account_number") // keep as string to preserve leading zeros
  currency          String           @default("CAD") @map("currency")
  isPrimary         Boolean          @default(false) @map("is_primary")

  // Distribution Logic
  label             String?          @map("label") // "Main", "Alimony", "Savings"
  type              DistributionType @default(REMAINDER) @map("type")
  value             Decimal?         @db.Decimal(10, 2) @map("value") // The $ or % amount
  priority          Int              @default(1) @map("priority") // Process Fixed/Percentage before Remainder
  isActive          Boolean          @default(true) @map("is_active")

  employee          Employee         @relation(fields: [employeeId], references: [id])
  // Prisma uses the @relation line to understand how to perform JOINs
  employeeId        String           @map("employee_id")

  @@index([employeeId])
  @@map("bank_accounts")
}

model PayrollDisbursement {
  id                   String             @id @default(cuid()) @map("id")
  payrollRunEmployeeId String             @map("payroll_run_employee_id")

  // Snapshot of bank details at time of payment
  institutionNumber    Int                @map("institution_number")
  branchNumber         Int                @map("branch_number")
  accountNumber        String             @map("account_number") // Masked or encrypted in production
  bankLabel            String?            @map("bank_label") // e.g., "Personal Savings" or "Alimony"

  amount               Decimal            @db.Decimal(10, 2) @map("amount")
  status               DisbursementStatus @default(PENDING) @map("status")

  // Tracking for bank file (ACH/EFT) generation
  referenceNumber      String?            @map("reference_number") // Trace ID from the bank
  processedAt          DateTime?          @map("processed_at")

  payrollRunEmployee   PayrollRunEmployee @relation(fields: [payrollRunEmployeeId], references: [id])

  @@index([payrollRunEmployeeId])
  @@map("payroll_disbursements")
}

model PayrollJournal {
  id           String         @id @default(cuid()) @map("id")
  payrollRunId String         @unique @map("payroll_run_id")
  tenantId     String         @map("tenant_id")

  status       JournalStatus  @default(PENDING) @map("status")
  postedAt     DateTime?      @map("posted_at")

  // Total checks for the entire journal
  totalDebit   Decimal        @db.Decimal(12, 2) @map("total_debit")
  totalCredit  Decimal        @db.Decimal(12, 2) @map("total_credit")

  entries      JournalEntry[]

  createdAt    DateTime       @default(now()) @map("created_at")
  @@index([tenantId])
  @@map("payroll_journals")
}

model JournalEntry {
  id               String         @id @default(cuid()) @map("id")
  payrollJournalId String         @map("payroll_journal_id")

  // Accounting Keys
  glAccountNumber  String?        @map("gl_account_number") // e.g., "5100" or "2100" for mapping to Chart of Accounts by computer
  glAccountName    String         @map("gl_account_name") // For human readability in exports

  type             EntryType      @map("type") // DEBIT or CREDIT
  amount           Decimal        @db.Decimal(12, 2) @map("amount")

  description      String?        @map("description") // e.g., "Gross Wages - Engineering - Period End 2023-10-01"

  journal          PayrollJournal @relation(fields: [payrollJournalId], references: [id])

  @@map("journal_entries")
}

model PaySlip {
  id         String   @id @default(uuid()) @map("id")
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  // Storage Metadata
  s3Key      String   @map("s3_key") // Path: "tenant_id/year/month/file.pdf"
  fileName   String   @map("file_name") // e.g., "PaySlip_Jan_2025.pdf"
  fileSize   Int      @map("file_size")
  employeeId String   @map("employee_id")
  tenantId   String   @map("tenant_id")

  @@index([employeeId])
  @@index([tenantId])
  @@index([tenantId, createdAt])
  @@index([employeeId, createdAt])
  @@map("pay_slips")
}

model Remittance {
  id                String                   @id @default(cuid()) @map("id")
  tenantId          String                   @map("tenant_id")

  // The reporting period
  periodYear        Int                      @map("period_year") // e.g., 2025
  periodMonth       Int                      @map("period_month") // e.g., 12

  // Totals for the filing
  totalGrossPayroll Decimal                  @db.Decimal(12, 2) @map("total_gross_payroll")
  totalEmployees    Int                      @map("total_employees")
  totalDue          Decimal                  @db.Decimal(12, 2) @map("total_due")

  status            RemittanceStatus         @default(PENDING) @map("status")
  paymentReference  String?                  @map("payment_reference") // Confirmation number from CRA My Business Account
  filedAt           DateTime?                @map("filed_at")

  // Links back to the source data
  payrollRuns       RemittanceToPayrollRun[]

  createdAt         DateTime                 @default(now()) @map("created_at")
  updatedAt         DateTime                 @updatedAt @map("updated_at")

  @@unique([tenantId, periodYear, periodMonth])
  @@index([tenantId, status])
  @@map("remittances")
}

model RemittanceToPayrollRun {
  remittanceId String @map("remittance_id")
  payrollRunId String @map("payroll_run_id")

  remittance   Remittance @relation(fields: [remittanceId], references: [id])

  @@id([remittanceId, payrollRunId])
  @@map("remittance_to_payroll_runs")
}

// ==========================================
// ===== ENUMS (Lowercase for Postgres) =====
// ==========================================

enum TokenType {
  EMAIL_VERIFICATION @map("email_verification")
  PASSWORD_RESET @map("password_reset")
  EMAIL_CHANGE @map("email_change")
	@@map("token_type")
}

enum UserRole {
  OWNER   @map("owner")      // Full access + billing
  ADMIN   @map("admin")         // Full payroll access
  MANAGER @map("manager")       // Can view/approve their department only
  ACCOUNTANT @map("accountant")    // Read-only access for tax/reports
  EMPLOYEE @map("employee")      // Can only see their own paystubs/profile
	@@map("user_role")
}

//Conflct resolution & precedence USER > SUPPORT > IMPORT > SYSTEM
enum NameSource {
  USER @map("user")
  SUPPORT @map("support") //e.g. manual change by support agent
  IMPORT @map("import") //sync from other services than contact management
  SYSTEM @map("system")  //e.g., auto-generated based on rules such as first name variations plus last name etc.
	@@map("conversational_name_source")
}


enum PhoneType {
  MOBILE @map("mobile")
  HOME @map("home")
  WORK @map("work")
	@@map("phone_type")
}

enum EmployeeStatus {
  ACTIVE @map("active")
  TERMINATED @map("terminated")
  ON_LEAVE @map("on_leave")
}

enum PayType {
  HOURLY @map("hourly")
  SALARY @map("salary")
	@@map("pay_type")
}

enum EarningType {
  REGULAR @map("regular")
  OVERTIME @map("overtime")
  BONUS @map("bonus")
  COMMISSION @map("commission")
  OTHER @map("other")
	@@map("earning_type")
}

enum PayrollRunStatus {
  DRAFT @map("draft")
  FINALIZED @map("finalized")
  PAID @map("paid")
	@@map("payroll_run_status")
}

enum DeductionType {
  TAX @map("tax")
  CPP @map("cpp")
  EI @map("ei")
  BENEFIT @map("benefit")
  OTHER @map("other")
	@@map("deduction_type")
}

//TODO: Distribution Validation: CREAT UNIQUE INDEX "OneRemainderAccountPerEmployee" ON "BankAccount"("employeeId) WHERE "type" = 'REMAINDER'; AND "isActive" = true;
enum DistributionType {
  FIXED_AMOUNT @map("fixed_amount")
  PERCENTAGE @map("percentage")
  REMAINDER @map("remainder")
}

enum DisbursementStatus {
  PENDING @map("pending")
  SENT @map("sent")
  FAILED @map("failed")
  RECONCILED @map("reconciled")
	@@map("disbursement_status")
}

enum PayFrequency {
  WEEKLY @map("weekly")
  BIWEEKLY @map("biweekly")
  SEMIMONTHLY @map("semimonthly")
  MONTHLY @map("monthly")
  ANNUALLY @map("annually")
	@@map("pay_frequency")
}

enum AccountType {
  ASSET @map("asset")
  LIABILITY @map("liability")
  EQUITY @map("equity")
  REVENUE @map("revenue")
  EXPENSE @map("expense")
  @@map("account_type")
}

enum AccountCategory {
  CASH @map("cash")
  PAYROLL_EXPENSE @map("payroll_expense")
  TAX_PAYABLE @map("tax_payable")
  BENEFIT_PAYABLE @map("benefit_payable")
  WAGES_PAYABLE @map("wages_payable")
  OTHER @map("other")
  @@map("account_category")
}

enum MappingType {
  EARNING @map("earning")
  DEDUCTION @map("deduction")
  EMPLOYER_TAX @map("employer_tax")
  NET_PAY_CLEARING @map("net_pay_clearing")
  @@map("mapping_type")
}

enum RemittanceStatus {
  PENDING @map("pending")
  REVIEWED @map("reviewed")
  FILED @map("filed")
  PAID @map("paid")
  CANCELLED @map("cancelled")
	@@map("remittance_status")
}

enum JournalStatus {
  PENDING @map("pending")
  POSTED @map("posted")      // Successfully synced to accounting software
  FAILED @map("failed")
  VOIDED @map("voided")
	@@map("journal_status")
}

enum EntryType {
  DEBIT @map("debit")
  CREDIT @map("credit")
	@@map("entry_type")
}

enum Subject {
  ORGANIZATION @map("organization")
  INDIVIDUAL @map("individual")
	@@map("subject")
}